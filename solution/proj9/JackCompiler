import sys
import re
import xml.etree.ElementTree as ET

filearg = sys.argv[1]

keyword = ['class','constructor','function','method','field','static','var','int','char','boolean','void','true', 'false','null','this', 'let','do','if','else', 'while','return']
symbol = ['{','}','(',')','[',']','.',',',';','+','-','*','/','&','|','>','<','=','~']


test = """
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/9/Average/Main.jack

// Inputs some numbers and computes their average
class Main {
   function void main() {
      var Array a; 
      var int length;
      var int i, sum;

      let length = Keyboard.readInt("How many numbers? ");
      let a = Array.splitBySpaces(length); // constructs the array
     
      let i = 0;
      while (i < length) {
         let a[i] = Keyboard.readInt("Enter a number: ");
         let sum = sum + a[i];
         let i = i + 1;
      }

      do Output.printString("The average is ");
      do Output.printInt(sum / length);
      return;
   }
}

"""

def isIntegerConstant(string):
    if string.isnumeric():
        num = int(string)
        if num >= 0 and num <= 32767:
            return True
        else:
            raise ValueError('number '+string+' overrange')
    else:
        return False
    

def isStringConstant(string):
    return '\"' == string[0] and '\"' == string[-1] and string != '\"'

def isIdentifier(string):
    return not string[0].isnumeric()

def tokenClassification(inputToken):
    if inputToken in keyword:
        return 'keyword'
    elif inputToken in symbol:
        return 'symbol'
    elif isIntegerConstant(inputToken):
        return 'integerConstant'
    elif isStringConstant(inputToken):
        return 'StringConstant'
    elif isIdentifier(inputToken):
        return 'identifier'
    else:
        raise TypeError
    


def partitioner(text):
    result = re.sub(r'/{2}.*\n','',text)
    print(result)

    # splitByNotions = re.split(r"([^a-zA-Z\s]| |\n)",result)
    # print(splitByNotions)
    splitByQuotes = re.split(r"(\".+?\")",result)
    splitByQuotesWtQuotes = []
    while (splitByQuotes):
        element = splitByQuotes.pop(0)
        if isStringConstant(element):
            splitByQuotesWtQuotes.append('\"')
            splitByQuotesWtQuotes.append(element)
            splitByQuotesWtQuotes.append('\"')
        else:
            splitByQuotesWtQuotes.append(element)

    print("splitByQuotesWtQuotes")
    print(splitByQuotesWtQuotes)

    splitBySpaces  = []
    for i in splitByQuotesWtQuotes:
        if not isStringConstant(i):
            splitBySpaces = splitBySpaces + i.split()
        else:
            splitBySpaces.append(i)
    print("splitBySpaces")
    print(splitBySpaces)

    finalList =[]
    for i in splitBySpaces:
        if not isStringConstant(i):
            for j in re.split(r'([^a-zA-Z\s])',i):
                if j != '':
                    finalList.append(j)
        else: 
            finalList.append(i)

    print("finalList")
    print(finalList)
    return finalList

with open(filearg,'r') as file:
    text = file.read()
    textList = partitioner(text)

tokens = []
def outputModifier(value,classi):#remove quotes and replace speciacl symbols
    if classi == 'StringConstant':
        return value[1:-1]
    # elif value == '<':
    #     return '&lt;'
    # elif value == '>':
    #     return '&gt;'
    # elif value == '\"':
    #     return '&quot;'
    # elif value == '>':
    #     return '&amp;'
    else:
        return value

data = ET.Element('data')
dataList = []
for i in textList:
    classification = tokenClassification(i)
    element = ET.SubElement(data,classification)
    element.text = outputModifier(i,classification)
    dataList.append([outputModifier(i,classification),classification])
    print("<"+classification+"> "+ outputModifier(i,classification) + " </"+classification+">")

ET.dump(data)

print(dataList)

xmlfile = ET.Element('xml')

p=0

def eat(string):
    global p
    if dataList[p][0] == string:
        p+= 1
    else:
        raise SyntaxError("a "+string+" is missing at"+p)

def compileStatements():
    pass

def compileIfStatement(handler):
    global p
    eat('(')
    compileExpression()
    eat(')')
    eat('{')
    compileStatements()
    eat('}')

def compileWhileStatement():
    global p
    eat('(')
    compileExpression()
    eat(')')
    eat('{')
    compileStatements()
    eat('}')

def compileLetStatement():
    pass

def compileExpression():
    pass

def compileTerm():
    pass

